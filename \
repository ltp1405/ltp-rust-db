use std::{
    mem::size_of,
    ptr::slice_from_raw_parts_mut,
    rc::Rc,
    sync::{Arc, Mutex},
};

use ltp_rust_db_page::{
    page::{Page, PAGE_SIZE},
    pager::Pager,
};

use super::{
    cell::Cell, CellPointer, CellsCount, NodePointer, NodeType, CELL_CONTENT_START, CELL_NUMS,
    CELL_POINTERS_ARRAY_OFFSET, CELL_POINTER_SIZE, NODE_TYPE, RIGHT_MOST_CHILD_POINTER,
};

#[derive(Debug)]
enum InsertDecision {
    Normal,
    Split,
    Overflow(usize),
}

/// Each node of the btree is contained inside 1 page
#[derive(Debug)]
pub struct Node {
    pager: Arc<Mutex<Pager>>,
    page_num: NodePointer,
}

#[derive(Debug, PartialEq)]
pub enum Slot {
    /// Represent a slot which is not occupied by a key yet
    Hole(u32),
    /// Represent a slot which is occupied by a key
    Cell(u32),
}

#[derive(Debug)]
enum InsertResult {
    KeyExisted(Node),
    Normal(Node),
    Splitted(NodePointer, Node, Node),
}

impl Node {
    pub fn new(page_num: usize, pager: Arc<Mutex<Pager>>) -> Self {
        let mut node = Node {
            page_num: page_num as u32,
            pager,
        };
        if node.cell_content_start() == 0 {
            node.set_cell_content_start(PAGE_SIZE as u32);
        }
        node
    }

    pub fn node_type(&self) -> NodeType {
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        unsafe { page.read_val_at(NODE_TYPE.0) }
    }

    // pub fn set_node_type(&mut self, node_type: NodeType) {
    //     unsafe {
    //         self.page.write_val_at(NODE_TYPE.0, node_type);
    //     }
    // }

    // pub fn parent_pointer(&self) -> u32 {
    //     unsafe { self.page.read_val_at(PARENT_POINTER.0) }
    // }

    // pub fn set_parent_pointer(&mut self, parent_pointer: u32) {
    //     unsafe {
    //         self.page.write_val_at(PARENT_POINTER.0, parent_pointer);
    //     }
    // }

    pub fn num_cells(&self) -> CellsCount {
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        unsafe { page.read_val_at(CELL_NUMS.0) }
    }

    pub fn set_num_cells(&mut self, num_cells: u32) {
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        unsafe {
            page.write_val_at(CELL_NUMS.0, num_cells);
        }
    }

    fn cell_pointer_offset(&self, cell_num: u32) -> usize {
        let val = CELL_POINTERS_ARRAY_OFFSET + CELL_POINTER_SIZE * cell_num as usize;
        val
    }

    fn read_cell_at<'a>(&'a self, page: &'a Page, cell_num: u32) -> Cell {
        Cell::table_leaf_at(&page, self.cell_pointer(cell_num) as usize)
    }

    fn cell_bound(&self, cell_num: u32) -> (usize, usize) {
        // if cell_num > self.num_cells() {
        //     panic!("Cell index out of bound");
        // }
        // let target = self.cell_pointer(cell_num) as usize;
        // let mut min = PAGE_SIZE;
        // for cell_num in 0..self.num_cells() {
        //     let off = self.cell_pointer(cell_num) as usize;
        //     if off <= target {
        //         continue;
        //     }
        //     if off < min {
        //         min = off
        //     }
        // }
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        let target = self.cell_pointer(cell_num) as usize;
        let cell = self.read_cell_at(&page, cell_num);
        (target, cell.cell_size() as usize)
    }

    fn right_child(&self) -> NodePointer {
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        unsafe { page.read_val_at(RIGHT_MOST_CHILD_POINTER.0) }
    }

    pub fn search(&self, search_key: u32) -> Slot {
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        let num_cells = self.num_cells();
        if num_cells == 0 {
            return Slot::Hole(0);
        }
        let mut hi = num_cells;
        let mut lo = 0;
        loop {
            let mid = (lo + hi) / 2;
            let mid_key = self.read_cell_at(&page, mid).key();
            if search_key < mid_key {
                if mid == 0 {
                    return Slot::Hole(0);
                } else if search_key > self.read_cell_at(&page, mid - 1).key() {
                    return Slot::Hole(mid);
                }
                hi = mid;
            } else if search_key > mid_key {
                if mid == num_cells - 1 {
                    return Slot::Hole(num_cells);
                }
                lo = mid;
            } else {
                return Slot::Cell(mid);
            }
        }
    }

    pub fn leaf_split_to(node: Node) -> (Node, Node) {
        let right = node.pager.lock().unwrap().get_free_page().unwrap();
        let right = Node::new(right as usize, node.pager.clone());
        todo!()
    }

    pub fn get_children(&self) -> Vec<NodePointer> {
        todo!()
    }

    pub fn insert_cell_pointer(&mut self, hole: u32, pointer: u32) {
        self.set_num_cells(self.num_cells() + 1);
        let cell_num = self.num_cells();
        for cell_i in (hole + 1..cell_num).rev() {
            self.set_cell_pointer(cell_i, self.cell_pointer(cell_i - 1));
        }
        self.set_cell_pointer(hole, pointer);
    }

    /// Insert a payload into a leaf node
    /// Return a normal node if insert normally
    /// Return a pair of node if need split
    fn leaf_insert(
        mut self,
        key: u32,
        payload: &[u8],
        overflow_head: Option<NodePointer>,
    ) -> InsertResult {
        match self.insert_decision(payload.len()) {
            InsertDecision::Normal => {
                let hole = self.search(key);
                let hole = match hole {
                    Slot::Hole(hole) => hole,
                    Slot::Cell(_cell) => panic!(),
                };
                let cell_start = self.cell_content_start();
                let page = self
                    .pager
                    .lock()
                    .unwrap()
                    .get_page(self.page_num as usize)
                    .unwrap();
                let cell = Cell::insert_table_leaf(
                    &page,
                    cell_start as usize,
                    key,
                    payload.len() as u32,
                    overflow_head,
                    &payload,
                );
                let cell_start = cell_start - (cell.header_size() as u32) - payload.len() as u32;
                self.set_cell_content_start(cell_start);
                self.insert_cell_pointer(hole, cell_start as u32);
                InsertResult::Normal(self)
            }
            InsertDecision::Overflow(kept_size) => {
                let hole = self.search(key);
                let hole = match hole {
                    Slot::Hole(hole) => hole,
                    Slot::Cell(_cell) => panic!(),
                };
                let mut pager = self.pager.lock().unwrap();
                let page = pager.get_page(self.page_num as usize).unwrap();
                let payload_len = payload.len();
                let (non_overflow, overflow) = payload.split_at(kept_size);
                let cell_start = self.cell_content_start();
                let new_page = pager.get_free_page().unwrap();
                let cell = Cell::insert_table_leaf(
                    &page,
                    cell_start as usize,
                    key,
                    payload_len as u32,
                    Some(new_page as u32),
                    non_overflow,
                );
                // TODO: Handle remain payload
                drop(pager);
                let cell_start = cell_start - (cell.header_size() as u32) - payload.len() as u32;
                self.set_cell_content_start(cell_start);
                self.insert_cell_pointer(hole, cell_start as u32);
                InsertResult::Normal(self)
            }
            InsertDecision::Split => {
                let page = self
                    .pager
                    .lock()
                    .unwrap()
                    .get_page(self.page_num as usize)
                    .unwrap();
                let new_page = self.pager.lock().unwrap().get_free_page().unwrap();
                let mut new_node = Node::new(new_page, self.pager.clone());
                let mid = self.num_cells() / 2;
                for i in mid..self.num_cells() {
                    let cell = Cell::table_leaf_at(&page, self.cell_pointer(i) as usize);
                    new_node = if let InsertResult::Normal(node) = new_node.leaf_insert(
                        cell.key(),
                        cell.not_overflowed_payload(),
                        cell.overflow_page_head(),
                    ) {
                        node
                    } else {
                        unreachable!()
                    };
                }
                // TODO: Handle hole after split
                let cell_bound = self.cell_bound(mid);
                let mid_key = Cell::table_leaf_at(&page, cell_bound.0).key();
                self.set_num_cells(mid);

                if key >= mid_key {
                    new_node = match new_node.leaf_insert(key, payload, overflow_head) {
                        InsertResult::Normal(node) => node,
                        _ => unreachable!("Maybe overflow calculation go wrong"),
                    }
                } else {
                    self = match self.leaf_insert(key, payload, overflow_head) {
                        InsertResult::Normal(node) => node,
                        _ => unreachable!("Maybe overflow calculation go wrong"),
                    }
                };
                InsertResult::Splitted(mid_key, self, new_node)
            }
        }
    }

    fn cell_at(&self, cell_num: u32) -> (Page, Cell) {
                    let mut pager = self.pager.lock().unwrap();
                    let page = pager.get_page(self.page_num as usize).unwrap();
                    let offset = self.cell_pointer(hole);
                    let cell = Cell::table_interior_at(&page, offset as usize);
    }

    pub fn node_insert(mut self, key: u32, payload: &[u8]) -> InsertResult {
        let node_type = self.node_type();
        match node_type {
            NodeType::Leaf => return self.leaf_insert(key, payload, None),
            NodeType::Interior => {
                // Find the child to insert the payload into
                let hole = self.search(key);
                let hole = match hole {
                    Slot::Hole(hole) => hole,
                    Slot::Cell(cell) => cell,
                };
                let result = {
                    let mut pager = self.pager.lock().unwrap();
                    let page = pager.get_page(self.page_num as usize).unwrap();
                    let offset = self.cell_pointer(hole);
                    let cell = Cell::table_interior_at(&page, offset as usize);
                    let to_insert_node = Node::new(cell.child() as usize, self.pager.clone());
                    to_insert_node.node_insert(key, payload);
                };
                match result {
                    InsertResult::Normal(node) => return InsertResult::Normal(node),
                    InsertResult::Splitted(key, left, right) => {
                        todo!()
                        // // Handle left child node
                        // Cell::insert_table_interior(
                        //     &page,
                        //     self.cell_content_start() as usize,
                        //     key,
                        //     left.page_num,
                        // );

                        // // Handle right child node
                        // if hole >= self.num_cells() {
                        //     todo!()
                        // } else {
                        //     let cell_start = left.cell_content_start();
                        //     let page = left
                        //         .pager
                        //         .lock()
                        //         .unwrap()
                        //         .get_page(left.page_num as usize)
                        //         .unwrap();
                        //     match left.insert_decision(size_of::<u32>()) {
                        //         InsertDecision::Normal => {
                        //             let cell = Cell::insert_table_interior(
                        //                 &page,
                        //                 cell_start as usize,
                        //                 key,
                        //                 left.page_num,
                        //             );
                        //             let cell_start = cell_start - (cell.header_size() as u32);
                        //             self.set_cell_content_start(cell_start);
                        //             self.insert_cell_pointer(hole, cell_start as u32);
                        //             InsertResult::Normal(self)
                        //         }
                        //         InsertDecision::Overflow(_) => unreachable!(),
                        //         InsertDecision::Split => {
                        //             todo!()
                                    // let page = left
                                    //     .pager
                                    //     .lock()
                                    //     .unwrap()
                                    //     .get_page(left.page_num as usize)
                                    //     .unwrap();
                                    // let new_page = pager.lock().unwrap().get_free_page().unwrap();
                                    // let mut new_node = Node::new(new_page, pager.clone());
                                    // let mid = self.num_cells() / 2;
                                    // for i in mid..self.num_cells() {
                                    //     let cell = Cell::table_leaf_at(
                                    //         &page,
                                    //         self.cell_pointer(i) as usize,
                                    //     );
                                    //     new_node = if let InsertResult::Normal(node) = new_node
                                    //         .leaf_insert(
                                    //             cell.key(),
                                    //             cell.not_overflowed_payload(),
                                    //             cell.overflow_page_head(),
                                    //         ) {
                                    //         node
                                    //     } else {
                                    //         unreachable!()
                                    //     };
                                    // }
                                    // // TODO: Handle hole after split
                                    // let cell_bound = self.cell_bound(mid);
                                    // let mid_key = Cell::table_leaf_at(&page, cell_bound.0).key();
                                    // self.set_num_cells(mid);

                                    // if key >= mid_key {
                                    //     let cell = Cell::insert_table_interior(
                                    //         &page,
                                    //         cell_start as usize,
                                    //         key,
                                    //         left.page_num,
                                    //     );
                                    //     let cell_start = cell_start - (cell.header_size() as u32);
                                    //     self.set_cell_content_start(cell_start);
                                    //     self.insert_cell_pointer(hole, cell_start as u32);
                                    // } else {
                                    //     let cell = Cell::insert_table_interior(
                                    //         &page,
                                    //         cell_start as usize,
                                    //         key,
                                    //         left.page_num,
                                    //     );
                                    //     let cell_start = cell_start - (cell.header_size() as u32);
                                    //     self.set_cell_content_start(cell_start);
                                    //     self.insert_cell_pointer(hole, cell_start as u32);
                                    // };
                                    // InsertResult::Splitted(mid_key, self, new_node)
                                }
                            }
                        }
                    }
                    InsertResult::KeyExisted(key) => return InsertResult::KeyExisted(key),
                }
            }
        }
    }

    // pub fn insert(&mut self, hole: u32, key: u32, payload: Vec<u8>) {
    //     let payload_size = payload.len();
    //     let overflow_size = self.overflow_amount(payload_size as u32);
    //     let (not_overflowed_payload, overflow_head) = match overflow_size {
    //         Some(overflow_size) => {
    //             if payload_size as u32 - overflow_size
    //                 < self.min_threshold_for_non_overflow() as u32
    //             {
    //                 self.split();
    //                 todo!("SPLIT HERE")
    //             } else {
    //                 let (not_overflowed_payload, overflow_payload) =
    //                     payload.split_at(payload_size - overflow_size as usize);
    //                 let page_num = self.pager.lock().unwrap().get_free_page().unwrap() as u32;
    //                 self.handle_overflow(page_num, overflow_payload);
    //                 (not_overflowed_payload, Some(page_num))
    //             }
    //         }
    //         None => (payload.as_slice(), None),
    //     };
    //     println!("Payload size {:?}", not_overflowed_payload.len());
    //     let cell = Cell::new_table_leaf(
    //         key,
    //         payload_size as u32,
    //         not_overflowed_payload.to_vec(),
    //         overflow_head,
    //     );
    //     println!("{:?}", cell);

    //     let cell_start = self.cell_content_start() as usize - cell.size();

    //     let slice = &mut self.page[cell_start as usize..(cell_start + cell.size()) as usize];
    //     assert_eq!(slice.len(), cell.size());
    //     unsafe {
    //         cell.serialize_to(slice);
    //     }

    //     self.set_cell_pointer(cell_num, cell_start as u32);

    //     self.set_cell_content_start(cell_start as u32);
    //     self.set_num_cells(self.num_cells() + 1);
    // }

    fn overflow_amount(&self, payload_size: u32) -> Option<u32> {
        let free_size = self.free_size();
        if payload_size < free_size as u32 - 12 {
            None
        } else {
            Some(payload_size - free_size as u32 + 200)
        }
    }

    fn min_threshold_for_non_overflow(&self) -> usize {
        let m = ((PAGE_SIZE - 12) * 32 / 255) - 23;
        println!("{}", m);
        m
    }

    // fn cells_content(&self) -> &[u8] {
    //     let start = self.cell_content_start();
    //     &self.page[start as usize..PAGE_SIZE as usize]
    // }

    fn cell_content_start(&self) -> u32 {
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        unsafe { page.read_val_at(CELL_CONTENT_START.0) }
    }

    fn set_cell_content_start(&mut self, val: u32) {
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        unsafe { page.write_val_at(CELL_CONTENT_START.0, val) }
    }

    fn set_cell_pointer(&mut self, cell_num: u32, val: u32) {
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        unsafe {
            page.write_val_at(self.cell_pointer_offset(cell_num), val);
        }
    }

    fn free_size(&self) -> usize {
        self.cell_content_start() as usize - self.cell_pointer_offset(self.num_cells())
    }

    fn cell_pointer(&self, cell_num: u32) -> CellPointer {
        let page = self
            .pager
            .lock()
            .unwrap()
            .get_page(self.page_num as usize)
            .unwrap();
        unsafe { page.read_val_at(self.cell_pointer_offset(cell_num)) }
    }

    fn insert_decision(&self, payload_size: usize) -> InsertDecision {
        if payload_size > 100 {
            InsertDecision::Overflow(30)
        } else if self.num_cells() > 3 {
            InsertDecision::Split
        } else {
            InsertDecision::Normal
        }
    }
}

#[cfg(test)]
mod node {
    use std::sync::{Arc, Mutex};

    use ltp_rust_db_page::pager::Pager;

    use crate::table::btree::node::node::InsertResult;

    use super::Node;

    #[test]
    fn insert_ptr() {
        let pager = Arc::new(Mutex::new(Pager::init("insert_ptr")));
        let mut node = Node::new(0, pager.clone());
        node.insert_cell_pointer(0, 12);
        assert_eq!(node.cell_pointer(0), 12);
        assert_eq!(node.num_cells(), 1);

        node.insert_cell_pointer(1, 15);
        assert_eq!(node.cell_pointer(1), 15);
        assert_eq!(node.num_cells(), 2);

        node.insert_cell_pointer(0, 1521);
        assert_eq!(node.cell_pointer(0), 1521);
        assert_eq!(node.num_cells(), 3);

        node.insert_cell_pointer(2, 643);
        assert_eq!(node.cell_pointer(2), 643);
        assert_eq!(node.num_cells(), 4);

        let page = pager.lock().unwrap().get_page(0).unwrap();
        println!("{:?}", page);
    }

    #[test]
    fn single_leaf_insert() {
        let pager = Arc::new(Mutex::new(Pager::init("insert_ptr")));
        let node = Node::new(0, pager.clone());
        let node =
            if let InsertResult::Normal(node) = node.leaf_insert(22, &[1, 2, 3, 4, 5, 6], None) {
                node
            } else {
                unreachable!()
            };
        let page = pager.lock().unwrap().get_page(0).unwrap();
        let cell = node.read_cell_at(&page, 0);
        assert_eq!(cell.not_overflowed_payload(), &[1, 2, 3, 4, 5, 6],);
    }

    #[test]
    fn leaf_insert_cell() {
        let pager = Arc::new(Mutex::new(Pager::init("insert_ptr")));
        let node = Node::new(0, pager.clone());
        let node =
            if let InsertResult::Normal(node) = node.leaf_insert(22, &[1, 2, 3, 4, 5, 6], None) {
                node
            } else {
                unreachable!()
            };
        let node = if let InsertResult::Normal(node) = node.leaf_insert(12, &[1, 2, 3], None) {
            node
        } else {
            unreachable!()
        };
        let node = if let InsertResult::Normal(node) = node.leaf_insert(124, &[1, 2, 5, 6], None) {
            node
        } else {
            unreachable!()
        };
        let page = pager.lock().unwrap().get_page(0).unwrap();
        let cell = node.read_cell_at(&page, 0);
        assert_eq!(cell.not_overflowed_payload(), &[1, 2, 3],);
        let cell = node.read_cell_at(&page, 1);
        assert_eq!(cell.not_overflowed_payload(), &[1, 2, 3, 4, 5, 6]);
        for i in 0..node.num_cells() - 1 {
            let lo = node.read_cell_at(&page, i).key();
            let hi = node.read_cell_at(&page, i + 1).key();
            assert!(lo < hi, "Key should be sorted: {} > {}", lo, hi);
        }
    }

    #[test]
    fn leaf_insert_split() {
        let pager = Arc::new(Mutex::new(Pager::init("insert_ptr")));
        let node = Node::new(0, pager.clone());
        let node = if let InsertResult::Normal(node) = node.leaf_insert(533, &[2; 50], None) {
            node
        } else {
            unreachable!()
        };
        let node = if let InsertResult::Normal(node) = node.leaf_insert(22, &[1; 12], None) {
            node
        } else {
            unreachable!()
        };
        let node = if let InsertResult::Normal(node) = node.leaf_insert(12, &[9; 3], None) {
            node
        } else {
            unreachable!()
        };
        let node = if let InsertResult::Normal(node) = node.leaf_insert(124, &[1, 2, 5, 6], None) {
            node
        } else {
            unreachable!()
        };
        let key = if let InsertResult::Splitted(k, l, r) = node.leaf_insert(5, &[4; 15], None) {
            let l_page = pager.lock().unwrap().get_page(l.page_num as usize).unwrap();
            let r_page = pager.lock().unwrap().get_page(r.page_num as usize).unwrap();
            let cell = l.read_cell_at(&l_page, 0);
            assert_eq!(cell.key(), 5);
            assert_eq!(cell.not_overflowed_payload(), &[4; 15]);

            let cell = l.read_cell_at(&l_page, 1);
            assert_eq!(cell.key(), 12);
            assert_eq!(cell.not_overflowed_payload(), &[9; 3]);

            let cell = r.read_cell_at(&r_page, 0);
            assert_eq!(cell.key(), 124);
            assert_eq!(cell.not_overflowed_payload(), &[1, 2, 5, 6]);

            let cell = r.read_cell_at(&r_page, 1);
            assert_eq!(cell.key(), 533);
            assert_eq!(cell.not_overflowed_payload(), &[2; 50]);
            // println!("{:?}", l_page);
            // println!("{:?}", r_page);
            k
        } else {
            unreachable!()
        };
        println!("{:?}", key);
    }
}
